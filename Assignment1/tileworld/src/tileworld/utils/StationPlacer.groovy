/**
    Algorithm Generated by DeepSeek R1
 **/

package tileworld.utils

import groovy.transform.CompileStatic

import repast.simphony.random.RandomHelper
import repast.simphony.space.grid.GridPoint

@CompileStatic
class StationPlacer {

    private static class Point {
        double x, y

        Point(double x, double y) {
            this.x = x
            this.y = y
        }
        
        def asType(Class type) {
            if (type == GridPoint) return new GridPoint(x as int, y as int)
            super.asType(type)
        }
    }

    static List<GridPoint> getResult(int n, double W, double H) {
        def iterations = 1000
        def points = placeStations(n, W, H, iterations)
        points.collect { it as GridPoint }
    }

    static List<Point> placeStations(int n, double W, double H, int iterations) {
        def points = initializePoints(n, W, H)
        def area = W * H
        def idealSpacing = Math.sqrt(area / n) * 0.8 // Ideal spacing factor, adjustable

        iterations.times { i ->
            points = adjustPoints(points, W, H, idealSpacing, 0.2 * (1 - i / iterations))
        }
        points
    }

    static List<Point> initializePoints(int n, double W, double H) {
        (0..<n).collect { new Point(RandomHelper.nextDouble() * W, RandomHelper.nextDouble() * H) }
    }

    private static List<Point> adjustPoints(List<Point> points, double W, double H, double s, double stepSize) {
        List<Point> newPoints = []

        points.each { p ->
            def (fx, fy) = [0, 0]

            // Repulsive force between points
            points.each { q ->
                if (p.is(q)) return
                def dx = q.x - p.x
                def dy = q.y - p.y
                def distance = Math.hypot(dx, dy)

                if (distance < s) {
                    def force = (s - distance) / (distance + 1e-8)
                    fx -= dx * force
                    fy -= dy * force
                }
            }

            // Repulsive force from boundaries
            addBoundaryForce(p, W, H, s, [fx, fy] as double[])

            // Update position
            def newX = clamp(p.x + fx * stepSize, 0, W)
            def newY = clamp(p.y + fy * stepSize, 0, H)
            newPoints << new Point(newX, newY)
        }
        
        return newPoints
    }

    private static void addBoundaryForce(Point p, double W, double H, double s, double[] force) {
        def buffer = s * 0.5  // Boundary buffer factor

        // Left and right boundaries
        if (p.x < buffer) force[0] += buffer - p.x
        if (W - p.x < buffer) force[0] -= buffer - (W - p.x)

        // Top and bottom boundaries
        if (p.y < buffer) force[1] += buffer - p.y
        if (H - p.y < buffer) force[1] -= buffer - (H - p.y)
    }

    private static double clamp(double value, double min, double max) {
        Math.max(min, Math.min(max, value))
    }
}

